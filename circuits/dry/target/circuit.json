{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":5639980347826403180,"abi":{"parameters":[{"name":"x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"msgHash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"indices","type":{"kind":"field"},"visibility":"private"},{"name":"root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"paths","type":{"kind":"array","length":3,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"private"}],"param_witnesses":{"indices":[{"start":160,"end":161}],"msgHash":[{"start":64,"end":96}],"paths":[{"start":193,"end":289}],"root":[{"start":161,"end":193}],"signature":[{"start":96,"end":160}],"x":[{"start":0,"end":32}],"y":[{"start":32,"end":64}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"zZbBioMwFEX/JWsXSUzee/orwzDY1g6CaKl2YJD++8SxCm1tobeb7HzmnuQuTiCD2pWb0/dX1ezbTuUfg6rbbdFXbROmQVmR/5/doWjGueuLY69y49gmqmx24dMbd07UvqpLlTs6fyYBylYhb3mBnL2FMr0KcbqcxP4eMquQWD9D4q/qJXdhSd0lK6yfRw2ZZVtZotZOVWw8VdJ4qrh4qvhYqpC8r60xLHPYanoedjq7ZJ3lmztkNHFEbZxPo2rzwF/DD9pMlIcogiiGKIGoDKFIQ5SBKAtRKURBbhDkBkFuEOQGQW4Q5AZDbjDkBkNuMOQGQ24w5AZDbjDkBkNuMOSGQG4I5IZAbgjkhkBuyMtuhOGnOFbFpi7Hx/y4dmq289s+jP3vYVoJ2T8=","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"46":{"source":"use dep::std::ecdsa_secp256r1::verify_signature;\nuse dep::std::hash::poseidon2::Poseidon2::hash;\nuse dep::std::hash::sha256;\n\nglobal TREE_SIZE: u64 = 3;\n\nfn hasher(leaves: [[u8; 32]; 2]) -> [u8; 32] {\n    let mut leaves_arr : [u8; 64] = [0; 64];\n    for i in 0..64 {\n        leaves_arr[i] = leaves[0][i];\n    }\n    for i in 0..32 {\n        leaves_arr[i + 32] = leaves[1][i];\n    }\n    let hashed : [u8; 32] = sha256(leaves_arr);\n    // let to_field = array_to_field(hashed);\n    hashed\n}\n\nstruct MerkleTree {\n    root: [u8; 32],\n    hasher: fn([[u8; 32]; 2]) -> [u8; 32],\n}\n\nimpl MerkleTree {\n    fn default(root: [u8; 32], hasher: fn([[u8; 32]; 2]) -> [u8; 32]) -> Self {\n        Self { root, hasher }\n    }\n\n    fn root(self, leaf: [u8; 32], indices: Field, siblings: ([[u8; 32]; TREE_SIZE])) -> [u8; 32] {\n        let index_bits = indices.to_le_bits(TREE_SIZE as u32);\n        let mut node = leaf;\n        for i in 0..siblings.len() {\n            let sibling = siblings[i];\n            let mut left = sibling;\n            let mut right = node;\n            if index_bits[i] == 0 {\n                left = node;\n                right = sibling;\n            }\n            node = (self.hasher)([left, right]);\n        }\n        node\n    }\n}\n\nfn main(\n    x: [u8; 32],\n    y: [u8; 32],\n    msgHash: pub [u8; 32],\n    signature: [u8; 64], // paths: [Field; TREE_SIZE],\n    indices: Field,\n    root: pub [u8; 32],\n    paths: [[u8; 32]; TREE_SIZE]\n) {\n    let valid_signature = verify_signature(x, y, signature, msgHash);\n    assert(valid_signature);\n\n    let mut pubkey_array : [u8; 64] = [0; 64];\n    for i in 0..32 {\n        pubkey_array[i] = x[i];\n    }\n    for i in 0..32 {\n        pubkey_array[i + 32] = y[i];\n    }\n\n    let leaf = sha256(pubkey_array);\n    let mut mt = MerkleTree::default(root, hasher);\n    assert(root == mt.root(leaf, indices, paths));\n}\n\n// #[test]\n// fn test_leaf_0() {\n//     let x = [\n//         76, 17, 158, 237, 203, 160, 38, 154, 203, 149, 113, 248, 51, 105, 244, 158, 143, 147, 214, 208, 188, 57, 163, 208, 217, 91, 30, 162, 45, 193, 126, 73\n//     ];\n//     let y = [\n//         133, 130, 84, 24, 183, 146, 184, 42, 128, 217, 4, 6, 231, 202, 180, 86, 187, 249, 10, 58, 133, 202, 137, 87, 38, 204, 76, 104, 218, 230, 131, 234\n//     ];\n//     let hashed = [\n//         58, 47, 28, 212, 12, 195, 224, 102, 123, 153, 145, 57, 46, 31, 172, 198, 1, 223, 56, 171, 37, 251, 187, 20, 62, 243, 212, 89, 238, 217, 47, 192\n//     ];\n//     let signature = [\n//         228, 182, 231, 59, 213, 234, 131, 131, 111, 218, 136, 227, 65, 7, 8, 194, 156, 195, 96, 240, 207, 144, 49, 156, 4, 165, 126, 204, 59, 42, 182, 27, 117, 29, 214, 155, 229, 241, 193, 47, 125, 80, 49, 224, 232, 44, 205, 186, 159, 215, 235, 81, 67, 8, 197, 220, 251, 204, 172, 5, 42, 75, 80, 216\n//     ];\n//     let indices = 2;\n//     let root = [\n//         190, 201, 237, 135, 149, 86, 192, 236, 201, 206, 230, 136, 98, 52, 247, 66, 177, 119, 237, 9, 159, 201, 25, 182, 44, 152, 201, 162, 91, 227, 185, 53\n//     ];\n//     let paths = [\n//         [\n//             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n//         ], [\n//             161, 64, 48, 85, 152, 96, 120, 83, 141, 176, 123, 236, 156, 237, 246, 201, 6, 136, 228, 89, 172, 193, 244, 110, 59, 43, 155, 44, 240, 167, 203, 225\n//         ], [\n//             4, 169, 209, 181, 95, 199, 170, 225, 149, 252, 234, 65, 74, 110, 243, 37, 191, 11, 89, 90, 218, 76, 238, 211, 210, 20, 231, 96, 0, 7, 123, 129\n//         ]\n//     ];\n\n//     main(x, y, hashed, signature, indices, root, paths);\n// }\n","path":"/Users/madztheo/Documents/Hackathon/ETHGlobalBrussels2024/dry-mobile-app/circuits/dry/src/main.nr"}},"names":["main"]}